<!DOCTYPE html>

<html>
<head>
  <title>broadcast.py</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="__init__.html">
                __init__.py
              </a>
            
              
              <a class="source" href="base.html">
                base.py
              </a>
            
              
              <a class="source" href="blog.html">
                blog.py
              </a>
            
              
              <a class="source" href="broadcast.html">
                broadcast.py
              </a>
            
              
              <a class="source" href="error.html">
                error.py
              </a>
            
              
              <a class="source" href="forms.html">
                forms.py
              </a>
            
              
              <a class="source" href="keywords.html">
                keywords.py
              </a>
            
              
              <a class="source" href="leads.html">
                leads.py
              </a>
            
              
              <a class="source" href="logging_helper.html">
                logging_helper.py
              </a>
            
              
              <a class="source" href="nurturing.html">
                nurturing.py
              </a>
            
              
              <a class="source" href="prospects.html">
                prospects.py
              </a>
            
              
              <a class="source" href="settings.html">
                settings.py
              </a>
            
              
              <a class="source" href="utils.html">
                utils.py
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>broadcast.py</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">from</span> base <span class="keyword">import</span> BaseClient

HUBSPOT_BROADCAST_API_VERSION = <span class="string">'1'</span>


<span class="class"><span class="keyword">class</span> <span class="title">BaseSocialObject</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">_camel_case_to_underscores</span><span class="params">(self, text)</span>:</span>
        result = []
        pos = <span class="number">0</span>
        <span class="keyword">while</span> pos &lt; len(text):
            <span class="keyword">if</span> text[pos].isupper():
                <span class="keyword">if</span> pos - <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> text[pos - <span class="number">1</span>].islower() <span class="keyword">or</span> pos - <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> pos + <span class="number">1</span> &lt; len(text) <span class="keyword">and</span> text[pos + <span class="number">1</span>].islower():
                    result.append(<span class="string">"_%s"</span> % text[pos].lower())
                <span class="keyword">else</span>:
                    result.append(text[pos].lower())
            <span class="keyword">else</span>:
                result.append(text[pos])
            pos += <span class="number">1</span>
        <span class="keyword">return</span> <span class="string">""</span>.join(result)

    <span class="function"><span class="keyword">def</span> <span class="title">_underscores_to_camel_case</span><span class="params">(self, text)</span>:</span>
        result = []
        pos = <span class="number">0</span>
        <span class="keyword">while</span> pos &lt; len(text):
            <span class="keyword">if</span> text[pos] == <span class="string">"_"</span> <span class="keyword">and</span> pos + <span class="number">1</span> &lt; len(text):
                result.append(<span class="string">"%s"</span> % text[pos + <span class="number">1</span>].upper())
                pos += <span class="number">1</span>
            <span class="keyword">else</span>:
                result.append(text[pos])
            pos += <span class="number">1</span>
        <span class="keyword">return</span> <span class="string">""</span>.join(result)

    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>
        dict_self = {}
        <span class="keyword">for</span> key <span class="keyword">in</span> vars(self):
            dict_self[self._underscores_to_camel_case(key)] = getattr(self, key)
        <span class="keyword">return</span> dict_self

    <span class="function"><span class="keyword">def</span> <span class="title">from_dict</span><span class="params">(self, data)</span>:</span>
        accepted_fields = self.accepted_fields()
        <span class="keyword">for</span> key <span class="keyword">in</span> data:
            <span class="keyword">if</span> key <span class="keyword">in</span> accepted_fields:
                setattr(self, self._camel_case_to_underscores(key), data[key])


<span class="class"><span class="keyword">class</span> <span class="title">Broadcast</span><span class="params">(BaseSocialObject)</span>:</span>
    <span class="string">'''Defines a social media broadcast message for the broadcast api'''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Constants for remote content type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    COS_LP = <span class="string">"coslp"</span>
    COS_BLOG = <span class="string">"cosblog"</span>
    LEGACY_LP = <span class="string">"cmslp"</span>
    LEGACY_BLOG = <span class="string">"cmsblog"</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, broadcast_data)</span>:</span>
        self.data_parse(broadcast_data)

    <span class="function"><span class="keyword">def</span> <span class="title">accepted_fields</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> [
            <span class="string">'broadcastGuid'</span>,
            <span class="string">'campaignGuid'</span>,
            <span class="string">'channel'</span>,
            <span class="string">'channelGuid'</span>,
            <span class="string">'clicks'</span>,
            <span class="string">'clientTag'</span>,
            <span class="string">'content'</span>,
            <span class="string">'createdAt'</span>,
            <span class="string">'createdBy'</span>,
            <span class="string">'finishedAt'</span>,
            <span class="string">'groupGuid'</span>,
            <span class="string">'interactions'</span>,
            <span class="string">'interactionCounts'</span>,
            <span class="string">'linkGuid'</span>,
            <span class="string">'message'</span>,
            <span class="string">'messageUrl'</span>,
            <span class="string">'portalId'</span>,
            <span class="string">'remoteContentId'</span>,
            <span class="string">'remoteContentType'</span>,
            <span class="string">'status'</span>,
            <span class="string">'triggerAt'</span>,
            <span class="string">'updatedBy'</span>
        ]

    <span class="function"><span class="keyword">def</span> <span class="title">data_parse</span><span class="params">(self, broadcast_data)</span>:</span>
        self.from_dict(broadcast_data)


<span class="class"><span class="keyword">class</span> <span class="title">Channel</span><span class="params">(BaseSocialObject)</span>:</span>
    <span class="string">'''Defines the social media channel for the broadcast api'''</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, channel_data)</span>:</span>
        self.data_parse(channel_data)

    <span class="function"><span class="keyword">def</span> <span class="title">accepted_fields</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> [<span class="string">'channelGuid'</span>, <span class="string">'accountGuid'</span>, <span class="string">'account'</span>,
            <span class="string">'type'</span>, <span class="string">'name'</span>, <span class="string">'dataMap'</span>, <span class="string">'createdAt'</span>, <span class="string">'settings'</span>]

    <span class="function"><span class="keyword">def</span> <span class="title">data_parse</span><span class="params">(self, channel_data)</span>:</span>
        self.from_dict(channel_data)


<span class="class"><span class="keyword">class</span> <span class="title">BroadcastClient</span><span class="params">(BaseClient)</span>:</span>
    <span class="string">'''Broadcast API to manage messages published to social networks'''</span>

    <span class="function"><span class="keyword">def</span> <span class="title">_get_path</span><span class="params">(self, method)</span>:</span>
        <span class="keyword">return</span> <span class="string">'broadcast/v%s/%s'</span> % (HUBSPOT_BROADCAST_API_VERSION, method)

    <span class="function"><span class="keyword">def</span> <span class="title">get_broadcast</span><span class="params">(self, broadcast_guid, **kwargs)</span>:</span>
        <span class="string">'''
        Get a specific broadcast by guid
        '''</span>
        params = kwargs
        broadcast = self._call(<span class="string">'broadcasts/%s'</span> % broadcast_guid,
            params=params, content_type=<span class="string">'application/json'</span>)
        <span class="keyword">return</span> Broadcast(broadcast)

    <span class="function"><span class="keyword">def</span> <span class="title">get_broadcasts</span><span class="params">(self, type=<span class="string">""</span>, page=None,
            remote_content_id=None, limit=None, **kwargs)</span>:</span>
        <span class="string">'''
        Get all broadcasts, with optional paging and limits.
        Type filter can be 'scheduled', 'published' or 'failed'
        '''</span>
        <span class="keyword">if</span> remote_content_id:
            <span class="keyword">return</span> self.get_broadcasts_by_remote(remote_content_id)

        params = {<span class="string">'type'</span>: type}
        <span class="keyword">if</span> page:
            params[<span class="string">'page'</span>] = page

        params.update(kwargs)

        result = self._call(<span class="string">'broadcasts'</span>, params=params,
            content_type=<span class="string">'application/json'</span>)
        broadcasts = [Broadcast(b) <span class="keyword">for</span> b <span class="keyword">in</span> result]

        <span class="keyword">if</span> limit:
            <span class="keyword">return</span> broadcasts[:limit]
        <span class="keyword">return</span> broadcasts

    <span class="function"><span class="keyword">def</span> <span class="title">create_broadcast</span><span class="params">(self, broadcast)</span>:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(broadcast, dict):
            <span class="keyword">return</span> self._call(<span class="string">'broadcasts'</span>, data=broadcast.to_dict(),
                method=<span class="string">'POST'</span>, content_type=<span class="string">'application/json'</span>)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> self._call(<span class="string">'broadcasts'</span>, data=broadcast,
                method=<span class="string">'POST'</span>, content_type=<span class="string">'application/json'</span>)

    <span class="function"><span class="keyword">def</span> <span class="title">cancel_broadcast</span><span class="params">(self, broadcast_guid)</span>:</span>
        <span class="string">'''
        Cancel a broadcast specified by guid
        '''</span>
        subpath = <span class="string">'broadcasts/%s/update'</span> % broadcast_guid
        broadcast = {<span class="string">'status'</span>: <span class="string">'CANCELED'</span>}
        bcast_dict = self._call(subpath, method=<span class="string">'POST'</span>, data=broadcast,
            content_type=<span class="string">'application/json'</span>)
        <span class="keyword">return</span> bcast_dict

    <span class="function"><span class="keyword">def</span> <span class="title">get_channel</span><span class="params">(self, channel_guid)</span>:</span>
        channel = self._call(<span class="string">'channels/%s'</span> % channel_guid,
            content_type=<span class="string">'application/json'</span>)
        <span class="keyword">return</span> Channel(channel)

    <span class="function"><span class="keyword">def</span> <span class="title">get_channels</span><span class="params">(self, current=True, publish_only=False, settings=False)</span>:</span>
        <span class="string">"""
            if "current" is false it will return all channels that a user
            has published to in the past.

            if publish_only is set to true, then return only the channels
            that are publishable.

            if settings is true, the API will make extra queries to return
            the settings for each channel.
        """</span>
        <span class="keyword">if</span> publish_only:
            <span class="keyword">if</span> current:
                endpoint = <span class="string">'channels/setting/publish/current'</span>
            <span class="keyword">else</span>:
                endpoint = <span class="string">'channels/setting/publish'</span>
        <span class="keyword">else</span>:
            <span class="keyword">if</span> current:
                endpoint = <span class="string">'channels/current'</span>
            <span class="keyword">else</span>:
                endpoint = <span class="string">'channels'</span>

        result = self._call(endpoint, content_type=<span class="string">'application/json'</span>, params=dict(settings=settings))
        <span class="keyword">return</span> [Channel(c) <span class="keyword">for</span> c <span class="keyword">in</span> result]</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
